{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*!\n * Toastify js 1.9.3\n * https://github.com/apvarun/toastify-js\n * @license MIT licensed\n *\n * Copyright (C) 2018 Varun A P\n */\n(function (root, factory) {\n  if ((typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) === \"object\" && module.exports) {\n    module.exports = factory();\n  } else {\n    root.Toastify = factory();\n  }\n})(this, function (global) {\n  // Object initialization\n  var Toastify = function Toastify(options) {\n    // Returning a new init object\n    return new Toastify.lib.init(options);\n  },\n      // Library version\n  version = \"1.9.3\"; // Defining the prototype of the object\n\n\n  Toastify.lib = Toastify.prototype = {\n    toastify: version,\n    constructor: Toastify,\n    // Initializing the object with required parameters\n    init: function init(options) {\n      // Verifying and validating the input object\n      if (!options) {\n        options = {};\n      } // Creating the options object\n\n\n      this.options = {};\n      this.toastElement = null; // Validating the options\n\n      this.options.text = options.text || \"Hi there!\"; // Display message\n\n      this.options.node = options.node; // Display content as node\n\n      this.options.duration = options.duration === 0 ? 0 : options.duration || 3000; // Display duration\n\n      this.options.selector = options.selector; // Parent selector\n\n      this.options.callback = options.callback || function () {}; // Callback after display\n\n\n      this.options.destination = options.destination; // On-click destination\n\n      this.options.newWindow = options.newWindow || false; // Open destination in new window\n\n      this.options.close = options.close || false; // Show toast close icon\n\n      this.options.gravity = options.gravity === \"bottom\" ? \"toastify-bottom\" : \"toastify-top\"; // toast position - top or bottom\n\n      this.options.positionLeft = options.positionLeft || false; // toast position - left or right\n\n      this.options.position = options.position || ''; // toast position - left or right\n\n      this.options.backgroundColor = options.backgroundColor; // toast background color\n\n      this.options.avatar = options.avatar || \"\"; // img element src - url or a path\n\n      this.options.className = options.className || \"\"; // additional class names for the toast\n\n      this.options.stopOnFocus = options.stopOnFocus === undefined ? true : options.stopOnFocus; // stop timeout on focus\n\n      this.options.onClick = options.onClick; // Callback after click\n\n      this.options.offset = options.offset || {\n        x: 0,\n        y: 0\n      }; // toast offset\n      // Returning the current object for chaining functions\n\n      return this;\n    },\n    // Building the DOM element\n    buildToast: function buildToast() {\n      // Validating if the options are defined\n      if (!this.options) {\n        throw \"Toastify is not initialized\";\n      } // Creating the DOM object\n\n\n      var divElement = document.createElement(\"div\");\n      divElement.className = \"toastify on \" + this.options.className; // Positioning toast to left or right or center\n\n      if (!!this.options.position) {\n        divElement.className += \" toastify-\" + this.options.position;\n      } else {\n        // To be depreciated in further versions\n        if (this.options.positionLeft === true) {\n          divElement.className += \" toastify-left\";\n          console.warn('Property `positionLeft` will be depreciated in further versions. Please use `position` instead.');\n        } else {\n          // Default position\n          divElement.className += \" toastify-right\";\n        }\n      } // Assigning gravity of element\n\n\n      divElement.className += \" \" + this.options.gravity;\n\n      if (this.options.backgroundColor) {\n        divElement.style.background = this.options.backgroundColor;\n      } // Adding the toast message/node\n\n\n      if (this.options.node && this.options.node.nodeType === Node.ELEMENT_NODE) {\n        // If we have a valid node, we insert it\n        divElement.appendChild(this.options.node);\n      } else {\n        divElement.innerHTML = this.options.text;\n\n        if (this.options.avatar !== \"\") {\n          var avatarElement = document.createElement(\"img\");\n          avatarElement.src = this.options.avatar;\n          avatarElement.className = \"toastify-avatar\";\n\n          if (this.options.position == \"left\" || this.options.positionLeft === true) {\n            // Adding close icon on the left of content\n            divElement.appendChild(avatarElement);\n          } else {\n            // Adding close icon on the right of content\n            divElement.insertAdjacentElement(\"afterbegin\", avatarElement);\n          }\n        }\n      } // Adding a close icon to the toast\n\n\n      if (this.options.close === true) {\n        // Create a span for close element\n        var closeElement = document.createElement(\"span\");\n        closeElement.innerHTML = \"&#10006;\";\n        closeElement.className = \"toast-close\"; // Triggering the removal of toast from DOM on close click\n\n        closeElement.addEventListener(\"click\", function (event) {\n          event.stopPropagation();\n          this.removeElement(this.toastElement);\n          window.clearTimeout(this.toastElement.timeOutValue);\n        }.bind(this)); //Calculating screen width\n\n        var width = window.innerWidth > 0 ? window.innerWidth : screen.width; // Adding the close icon to the toast element\n        // Display on the right if screen width is less than or equal to 360px\n\n        if ((this.options.position == \"left\" || this.options.positionLeft === true) && width > 360) {\n          // Adding close icon on the left of content\n          divElement.insertAdjacentElement(\"afterbegin\", closeElement);\n        } else {\n          // Adding close icon on the right of content\n          divElement.appendChild(closeElement);\n        }\n      } // Clear timeout while toast is focused\n\n\n      if (this.options.stopOnFocus && this.options.duration > 0) {\n        var self = this; // stop countdown\n\n        divElement.addEventListener(\"mouseover\", function (event) {\n          window.clearTimeout(divElement.timeOutValue);\n        }); // add back the timeout\n\n        divElement.addEventListener(\"mouseleave\", function () {\n          divElement.timeOutValue = window.setTimeout(function () {\n            // Remove the toast from DOM\n            self.removeElement(divElement);\n          }, self.options.duration);\n        });\n      } // Adding an on-click destination path\n\n\n      if (typeof this.options.destination !== \"undefined\") {\n        divElement.addEventListener(\"click\", function (event) {\n          event.stopPropagation();\n\n          if (this.options.newWindow === true) {\n            window.open(this.options.destination, \"_blank\");\n          } else {\n            window.location = this.options.destination;\n          }\n        }.bind(this));\n      }\n\n      if (typeof this.options.onClick === \"function\" && typeof this.options.destination === \"undefined\") {\n        divElement.addEventListener(\"click\", function (event) {\n          event.stopPropagation();\n          this.options.onClick();\n        }.bind(this));\n      } // Adding offset\n\n\n      if (_typeof(this.options.offset) === \"object\") {\n        var x = getAxisOffsetAValue(\"x\", this.options);\n        var y = getAxisOffsetAValue(\"y\", this.options);\n        var xOffset = this.options.position == \"left\" ? x : \"-\" + x;\n        var yOffset = this.options.gravity == \"toastify-top\" ? y : \"-\" + y;\n        divElement.style.transform = \"translate(\" + xOffset + \",\" + yOffset + \")\";\n      } // Returning the generated element\n\n\n      return divElement;\n    },\n    // Displaying the toast\n    showToast: function showToast() {\n      // Creating the DOM object for the toast\n      this.toastElement = this.buildToast(); // Getting the root element to with the toast needs to be added\n\n      var rootElement;\n\n      if (typeof this.options.selector === \"undefined\") {\n        rootElement = document.body;\n      } else {\n        rootElement = document.getElementById(this.options.selector);\n      } // Validating if root element is present in DOM\n\n\n      if (!rootElement) {\n        throw \"Root element is not defined\";\n      } // Adding the DOM element\n\n\n      rootElement.insertBefore(this.toastElement, rootElement.firstChild); // Repositioning the toasts in case multiple toasts are present\n\n      Toastify.reposition();\n\n      if (this.options.duration > 0) {\n        this.toastElement.timeOutValue = window.setTimeout(function () {\n          // Remove the toast from DOM\n          this.removeElement(this.toastElement);\n        }.bind(this), this.options.duration); // Binding `this` for function invocation\n      } // Supporting function chaining\n\n\n      return this;\n    },\n    hideToast: function hideToast() {\n      if (this.toastElement.timeOutValue) {\n        clearTimeout(this.toastElement.timeOutValue);\n      }\n\n      this.removeElement(this.toastElement);\n    },\n    // Removing the element from the DOM\n    removeElement: function removeElement(toastElement) {\n      // Hiding the element\n      // toastElement.classList.remove(\"on\");\n      toastElement.className = toastElement.className.replace(\" on\", \"\"); // Removing the element from DOM after transition end\n\n      window.setTimeout(function () {\n        // remove options node if any\n        if (this.options.node && this.options.node.parentNode) {\n          this.options.node.parentNode.removeChild(this.options.node);\n        } // Remove the elemenf from the DOM, only when the parent node was not removed before.\n\n\n        if (toastElement.parentNode) {\n          toastElement.parentNode.removeChild(toastElement);\n        } // Calling the callback function\n\n\n        this.options.callback.call(toastElement); // Repositioning the toasts again\n\n        Toastify.reposition();\n      }.bind(this), 400); // Binding `this` for function invocation\n    }\n  }; // Positioning the toasts on the DOM\n\n  Toastify.reposition = function () {\n    // Top margins with gravity\n    var topLeftOffsetSize = {\n      top: 15,\n      bottom: 15\n    };\n    var topRightOffsetSize = {\n      top: 15,\n      bottom: 15\n    };\n    var offsetSize = {\n      top: 15,\n      bottom: 15\n    }; // Get all toast messages on the DOM\n\n    var allToasts = document.getElementsByClassName(\"toastify\");\n    var classUsed; // Modifying the position of each toast element\n\n    for (var i = 0; i < allToasts.length; i++) {\n      // Getting the applied gravity\n      if (containsClass(allToasts[i], \"toastify-top\") === true) {\n        classUsed = \"toastify-top\";\n      } else {\n        classUsed = \"toastify-bottom\";\n      }\n\n      var height = allToasts[i].offsetHeight;\n      classUsed = classUsed.substr(9, classUsed.length - 1); // Spacing between toasts\n\n      var offset = 15;\n      var width = window.innerWidth > 0 ? window.innerWidth : screen.width; // Show toast in center if screen with less than or qual to 360px\n\n      if (width <= 360) {\n        // Setting the position\n        allToasts[i].style[classUsed] = offsetSize[classUsed] + \"px\";\n        offsetSize[classUsed] += height + offset;\n      } else {\n        if (containsClass(allToasts[i], \"toastify-left\") === true) {\n          // Setting the position\n          allToasts[i].style[classUsed] = topLeftOffsetSize[classUsed] + \"px\";\n          topLeftOffsetSize[classUsed] += height + offset;\n        } else {\n          // Setting the position\n          allToasts[i].style[classUsed] = topRightOffsetSize[classUsed] + \"px\";\n          topRightOffsetSize[classUsed] += height + offset;\n        }\n      }\n    } // Supporting function chaining\n\n\n    return this;\n  }; // Helper function to get offset.\n\n\n  function getAxisOffsetAValue(axis, options) {\n    if (options.offset[axis]) {\n      if (isNaN(options.offset[axis])) {\n        return options.offset[axis];\n      } else {\n        return options.offset[axis] + 'px';\n      }\n    }\n\n    return '0px';\n  }\n\n  function containsClass(elem, yourClass) {\n    if (!elem || typeof yourClass !== \"string\") {\n      return false;\n    } else if (elem.className && elem.className.trim().split(/\\s+/gi).indexOf(yourClass) > -1) {\n      return true;\n    } else {\n      return false;\n    }\n  } // Setting up the prototype for the init object\n\n\n  Toastify.lib.init.prototype = Toastify.lib; // Returning the Toastify function to be assigned to the window object/module\n\n  return Toastify;\n});","map":null,"metadata":{},"sourceType":"module"}